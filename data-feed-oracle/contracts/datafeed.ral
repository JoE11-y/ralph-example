struct Request {
    mut lat: U256,
    mut lon: U256,
    mut status: Bool,
    mut temp: ByteVec
}

Contract WeatherDataFeed(
    ownerId: ByteVec,
    mut authorizedOraclesCount: U256,
    mut lastTimestamp: U256,
    mut lastRequestId: ByteVec,
    fee: U256,
    feeWallet: Address
){
    mapping[Address, Bool] authorizedOracles
    mapping[ByteVec, Request] requests

    event NewRequest(requestId: ByteVec, lat: U256, lon: U256)
    event RequestCompleted(requestId: ByteVec, temp: ByteVec)

    enum ErrorCodes {
        UnauthorizedOracle = 0
        InvalidCaller = 1
        InvalidTimestamp = 2
    }

    @using(preapprovedAssets = true, updateFields = true)
    pub fn addOracle(newOracle: Address) -> () {
        checkCaller!(callerContractId!() == ownerId, ErrorCodes.InvalidCaller)
        let owner = callerAddress!()
        authorizedOracles.insert!(owner, newOracle, true)
        authorizedOraclesCount = authorizedOraclesCount + 1
    }

    @using(updateFields = true)
    pub fn removeOracle(oracle: Address) -> () {
        checkCaller!(callerContractId!() == ownerId, ErrorCodes.InvalidCaller)
        let owner = callerAddress!()
        authorizedOracles.remove!(owner, oracle)
        authorizedOraclesCount = authorizedOraclesCount - 1
    }

    @using(preapprovedAssets = true, checkExternalCaller = false)
    pub fn makeRequest(lat: U256, lon: U256) -> ByteVec {
        let caller = callerAddress!()

        // create request id
        let requestId = toByteVec!(lat) ++ toByteVec!(lon) ++ toByteVec!(blockTimeStamp!()) ++ toByteVec!(callerAddress!())
        
        let newRequest = Request {
            lat: lat,
            lon: lon,
            status: false,
            temp: zeros!(5) 
        }

        // pay fee to oracle
        transferToken!(caller, feeWallet, ALPH, fee)

        // add new request
        requests.insert!(caller, requestId, newRequest)
        
        // emit request
        emit NewRequest(requestId, lat, lon)

        return requestId
    }


    @using(updateFields = true)
    pub fn completeRequest(requestId: ByteVec, temp: ByteVec, publicKey: ByteVec, signature: ByteVec, timestamp: U256) -> () {
        let caller = callerAddress!()

        checkCaller!(authorizedOracles[caller], ErrorCodes.UnauthorizedOracle)

        assert!(lastTimestamp <= timestamp, ErrorCodes.InvalidTimestamp)

        // verify that tx was signed by supplied public key
        verifyTxSignature!(publicKey)

        // verify the signature
        let data = blake2b!(requestId ++ temp ++ toByteVec!(timestamp))
        verifySecP256K1!(data, publicKey, signature)

        let updatedRequest = Request {
            lat: requests[requestId].lat,
            lon: requests[requestId].lat,
            status: true,
            temp: temp 
        }

        requests[requestId] = updatedRequest

        lastTimestamp = blockTimeStamp!()
        lastRequestId = requestId

        // emit completed event
        emit RequestCompleted(requestId, temp)
    }

    pub fn getRequest(requestId: ByteVec) -> Request {
        return requests[requestId]
    }

}