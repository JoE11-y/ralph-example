const ONE = 1e18

enum Ramp {
  Cliff = 0
  Linear = 1
}

struct Milestone {
  mut timestamp: U256,
  mut ramp: U256,
  mut percentage: U256
}

Contract TokenVesting(
  metadataTemplateId: ByteVec,
  manager: Address,
  mut milestonesCount: U256,
  // mut lastReachedMilestone: U256,
  // mut totalClaimed: U256,
  // mut claimableAmount: U256,
  mut balance: U256,
  mut totalLocked: U256,
  mut recipients: U256
){
  mapping[U256, Milestone] milestones

  event Claim(recipient: Address, amount: U256)
  
  event MilestoneReached(index: U256)

  event NewRecipientAdded(recipient: Address, amount: U256)
  
  event NewRecipientsAdded(totalRecipients: U256, totalAmount: U256)

  enum ErrorCodes {
    InvalidCaller = 0
    MilestoneArrayEmpty = 1
    LastPercentageMustBe100 = 2
    OnlyLastPercentageCanBe100 = 3
    TimestampsNotSorted = 4
    PercentagesNotSorted = 5
    MoreThanTwoEqualPercentages = 6
    EqualPercentagesOnlyAllowedBeforeLinear = 7
    InsufficientAlph = 8
    AlreadyHasLock = 9
    InvalidInputArrays = 10
    InvalidTotalAmount = 11
  }

  // max milestones is 50
  @using(preapprovedAssets = true, updateFields = true)
  pub fn initialize(milestonesArr: [Milestone; 50]) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)

    assert!(len!(milestonesArr) > 0, ErrorCodes.MilestoneArrayEmpty)

    let mut current = milestonesArr[0]
    let mut twoInARow = false

    let milestonesLen = len!(milestonesArr)

    for (let mut index = 0; index < milestonesLen ; index = index + 1) {
      if(index != 0){
        let previous = current
        current = milestonesArr[index]

        assert!(previous.timestamp <= current.timestamp, ErrorCodes.TimestampsNotSorted)
        assert!(previous.percentage < current.percentage, ErrorCodes.PercentagesNotSorted)
        
        if(twoInARow){
          assert!(previous.percentage != current.percentage, ErrorCodes.MoreThanTwoEqualPercentages)
          assert!(current.ramp == Ramp.Linear, ErrorCodes.EqualPercentagesOnlyAllowedBeforeLinear)
        }
        twoInARow = previous.percentage == current.percentage
      }

      milestones.insert!(callerAddress!(), index, current)

      if (index == milestonesLen - 1){
        assert!(current.percentage != ONE, ErrorCodes.LastPercentageMustBe100)
      }else{
        assert!(current.percentage == ONE, ErrorCodes.OnlyLastPercentageCanBe100)
      }
    }
    milestonesCount = milestonesLen
  }

  @using(preapprovedAssets = true, updateFields = true)
  pub fn addRecipient(recipient: Address, amount: U256) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)
    
    createSub{caller -> ALPH : amount + 1 alph}(caller, recipient, amount)
    
    recipients = recipients + 1
    balance = balance + amount
    totalLocked = totalLocked + amount
    emit NewRecipientAdded(recipient, amount)
  }

  @using(preapprovedAssets = true, updateFields = true)
  pub fn addRecipients(addresses: [Address; 100], amounts: [U256; 100], totalAmount: U256) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)
    assert!(len!(addresses) == len!(amounts), ErrorCodes.InvalidInputArrays)

    totalLocked = totalLocked + totalAmount
    balance = balance + totalAmount
    let addresesLen = len!(addresses)
    recipients = recipients + addresesLen
    let mut totalAmountCheck = 0

    for (let mut index = 0; index < addresesLen; index = index + 1) {
      let currAddress = addresses[index]
      let currAmount = amounts[index]
      totalAmountCheck = totalAmountCheck + currAmount
      createSub{caller -> ALPH : currAmount + 1 alph}(caller, currAddress, currAmount)
    }

    assert!(totalAmountCheck == totalAmount, ErrorCodes.InvalidTotalAmount)
    emit NewRecipientsAdded(addresesLen, totalAmount)
  }

  @using(preapprovedAssets = true)
  fn createSub(caller: Address, recipient: Address, amount: U256) -> () {
    let path = toByteVec!(recipient)
    let metadataContractId = subContractId!(path)
    assert!(!contractExists!(metadataContractId), ErrorCodes.AlreadyHasLock)
    assert!(tokenRemaining!(caller, ALPH) >= amount + 1 alph, ErrorCodes.InsufficientAlph)
    let (encodedImmFields, encodedMutFields) = Metadata.encodeFields!(selfContract!(), recipient, amount, 0, 0)
    let _ = copyCreateSubContract!{caller -> ALPH : amount + 1 alph}(path, metadataTemplateId, encodedImmFields, encodedMutFields)
  }
}