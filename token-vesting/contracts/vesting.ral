const ONE = 1e18

enum Ramp {
  Cliff = 0
  Linear = 1
}

struct Milestone {
  mut timestamp: U256,
  mut ramp: U256,
  mut percentage: U256
}

struct UserMetadata {
  lockedAmount: U256,
  totalClaimed: U256,
  lastClaimTimestamp: U256
}

Contract TokenVesting(
  metadataTemplateId: ByteVec,
  manager: Address,
  startTime: U256,
  mut totalMilestones: U256,
  mut totalAmountLocked: U256,
  mut totalAmountUnlocked: U256,
  mut totalRecipients: U256,
  mut lastReachedMilestone: U256
){
  mapping[U256, Milestone] milestones

  event Claim(recipient: Address, amount: U256)
  
  event MilestoneReached(index: U256)

  event NewRecipientAdded(recipient: Address, amount: U256)
  
  event NewRecipientsAdded(totalRecipients: U256, totalAmount: U256)

  enum ErrorCodes {
    InvalidCaller = 0
    MilestoneArrayEmpty = 1
    LastPercentageMustBe100 = 2
    OnlyLastPercentageCanBe100 = 3
    TimestampsNotSorted = 4
    PercentagesNotSorted = 5
    InsufficientAlph = 8
    AlreadyHasLock = 9
    InvalidInputArrays = 10
    InvalidTotalAmount = 11
    MetadataNotExists = 12
  }

  // max milestones is 50
  @using(preapprovedAssets = true, updateFields = true)
  pub fn initialize(milestonesArr: [Milestone; 50]) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)

    assert!(len!(milestonesArr) > 0, ErrorCodes.MilestoneArrayEmpty)

    let mut current = milestonesArr[0]

    let milestonesLen = len!(milestonesArr)

    for (let mut index = 0; index < milestonesLen ; index = index + 1) {
      if(index != 0){
        let previous = current
        current = milestonesArr[index]

        assert!(previous.timestamp <= current.timestamp, ErrorCodes.TimestampsNotSorted)
        assert!(previous.percentage < current.percentage, ErrorCodes.PercentagesNotSorted)
      }

      milestones.insert!(callerAddress!(), index, current)

      if (index == milestonesLen - 1){
        assert!(current.percentage != ONE, ErrorCodes.LastPercentageMustBe100)
      }else{
        assert!(current.percentage == ONE, ErrorCodes.OnlyLastPercentageCanBe100)
      }
    }
    totalMilestones = milestonesLen
  }

  @using(preapprovedAssets = true, updateFields = true)
  pub fn addRecipient(recipient: Address, amount: U256) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)
    
    createSub{caller -> ALPH : amount + 1 alph}(caller, recipient, amount)
    
    totalRecipients = totalRecipients + 1
    totalAmountLocked = totalAmountLocked + amount
    emit NewRecipientAdded(recipient, amount)
  }

  @using(preapprovedAssets = true, updateFields = true)
  pub fn addRecipients(addresses: [Address; 100], amounts: [U256; 100], totalAmount: U256) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)
    assert!(len!(addresses) == len!(amounts), ErrorCodes.InvalidInputArrays)

    totalAmountLocked = totalAmountLocked + totalAmount
    let addresesLen = len!(addresses)
    totalRecipients = totalRecipients + addresesLen
    let mut totalAmountCheck = 0

    for (let mut index = 0; index < addresesLen; index = index + 1) {
      let currAddress = addresses[index]
      let currAmount = amounts[index]
      totalAmountCheck = totalAmountCheck + currAmount
      createSub{caller -> ALPH : currAmount + 1 alph}(caller, currAddress, currAmount)
    }

    assert!(totalAmountCheck == totalAmount, ErrorCodes.InvalidTotalAmount)
    emit NewRecipientsAdded(addresesLen, totalAmount)
  }

  @using(preapprovedAssets = true, updateFields = true)
  pub fn claim() -> () {
    let caller = callerAddress!()
    let metadata = getMetadata(caller)

    checkCaller!(caller == metadata.getAddress(), ErrorCodes.InvalidCaller)

    let currClaimIndex = metadata.getClaimIndex()
    let lastClaimTimestamp = metadata.getLastClaimedTime()

    updateLastReachedMilestone(lastReachedMilestone)
    
    let (percentage, claimIndex, currClaimTimestamp) = getClaimableRecord(currClaimIndex, lastClaimTimestamp)
    let amount = metadata.getLockedAmount() * percentage / ONE
    
    metadata.unlockToken(amount, claimIndex, currClaimTimestamp)
    
    totalAmountUnlocked = totalAmountUnlocked + amount
    emit Claim(caller, amount)
  }

  pub fn getClaimableAmount(address: Address) -> U256 {
    let metadata = getMetadata(address)
    let claimIndex = metadata.getClaimIndex()
    let lastClaimTimeStamp = metadata.getLastClaimedTime()
    let (percentage, _, _) = getClaimableRecord(claimIndex, lastClaimTimeStamp)
    let amount = metadata.getLockedAmount() * percentage / ONE
    return amount
  }

  pub fn getUserMetadata(address: Address) -> UserMetadata {
    let metadata = getMetadata(address)
    return UserMetadata { 
      lockedAmount: metadata.getLockedAmount(), 
      totalClaimed: metadata.getTotalClaimed(),
      lastClaimTimestamp: metadata.getLastClaimedTime()
    }
  }

  pub fn getAmountLeftInContract () -> U256 {
    return totalAmountLocked - totalAmountUnlocked
  }

  pub fn getMilestoneData (index: U256) -> Milestone {
    return milestones[index]
  }

  @using(updateFields = true, checkExternalCaller = false)
  pub fn updateLastReachedMilestone(startIndex: U256) -> (){
    let mut prevMilestone = milestones[startIndex]
    
    if (prevMilestone.timestamp > blockTimeStamp!()) {
      return
    }

    let mut lastIndex = lastReachedMilestone

    let mut loopComplete = false

    let mut index = startIndex
    while (index < totalMilestones && !loopComplete){
      let currMilestone = milestones[index]

      if (currMilestone.timestamp <= blockTimeStamp!()){
        prevMilestone = currMilestone
      }else{
        if (index > lastIndex + 1){
          lastIndex = index - 1
        }
        loopComplete = true
      }

      index = index + 1
    }

    if (!loopComplete && lastIndex < totalMilestones - 1){
      lastIndex = totalMilestones - 1
    }

    if(lastIndex != lastReachedMilestone){
      lastReachedMilestone = lastIndex
    }
  }

  fn getClaimableRecord(userClaimIndex: U256, lastClaimTimestamp: U256) -> (U256, U256, U256) {
    let mut prevMilestone = milestones[lastReachedMilestone]
    let mut percentage = 0
    let mut claimIndex = userClaimIndex
    let mut lastProcessedTimestamp = lastClaimTimestamp

    if(userClaimIndex > lastReachedMilestone) {
      return 0, claimIndex, lastProcessedTimestamp
    }

    if(prevMilestone.timestamp > blockTimeStamp!() && prevMilestone.ramp != Ramp.Linear){
      return 0, claimIndex, lastProcessedTimestamp
    }

    for (let mut index = lastReachedMilestone; index < totalMilestones; index = index + 1){
      let currentMilestone = milestones[index]
     
      if (currentMilestone.timestamp > blockTimeStamp!()){
        if (currentMilestone.ramp == Ramp.Linear) {

          let mut startPoint = prevMilestone.timestamp
          let mut startPercentage = prevMilestone.percentage

          if(lastProcessedTimestamp < prevMilestone.timestamp){
            if (index == 0 ){
              lastProcessedTimestamp = startTime
              startPoint = startTime
              startPercentage = 0
            }else{
              lastProcessedTimestamp = prevMilestone.timestamp
            }
          }

          let currTimestamp = blockTimeStamp!()
          
          percentage = percentage + ((currTimestamp - lastProcessedTimestamp) * (currentMilestone.percentage - startPercentage))
              / (currentMilestone.timestamp - startPoint)

          lastProcessedTimestamp = currTimestamp 
        }

        return percentage, claimIndex, lastProcessedTimestamp
      }
      
      lastProcessedTimestamp = currentMilestone.timestamp
      percentage = currentMilestone.percentage
      claimIndex = lastReachedMilestone
      prevMilestone = currentMilestone
    }

    return percentage, claimIndex, lastProcessedTimestamp
  }

  @using(preapprovedAssets = true)
  fn createSub(caller: Address, recipient: Address, amount: U256) -> () {
    let path = toByteVec!(recipient)
    let metadataContractId = subContractId!(path)
    assert!(!contractExists!(metadataContractId), ErrorCodes.AlreadyHasLock)
    assert!(tokenRemaining!(caller, ALPH) >= amount + 1 alph, ErrorCodes.InsufficientAlph)
    let (encodedImmFields, encodedMutFields) = Metadata.encodeFields!(selfContract!(), recipient, amount, 0, 0, 0)
    let _ = copyCreateSubContract!{caller -> ALPH : amount + 1 alph}(path, metadataTemplateId, encodedImmFields, encodedMutFields)
  }

  fn getMetadata(address: Address) -> Metadata {
    let metadataContractId = subContractId!(toByteVec!(address))
    assert!(contractExists!(metadataContractId), ErrorCodes.MetadataNotExists)
    return Metadata(metadataContractId)
  }
}