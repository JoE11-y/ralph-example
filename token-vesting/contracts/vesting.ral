const ONE = 1e18

enum Ramp {
  Cliff = 0
  Linear = 1
}

struct Milestone {
  mut timestamp: U256,
  mut ramp: U256,
  mut percentage: U256
}

struct UserMetadata {
  lockedAmount: U256,
  totalClaimed: U256,
  lastClaimTimestamp: U256
}

Contract TokenVesting(
  metadataTemplateId: ByteVec,
  manager: Address,
  mut totalMilestones: U256,
  mut totalAmountLocked: U256,
  mut totalAmountUnlocked: U256,
  mut totalRecipients: U256
){
  mapping[U256, Milestone] milestones

  event Claim(recipient: Address, amount: U256)
  
  event MilestoneReached(index: U256)

  event NewRecipientAdded(recipient: Address, amount: U256)
  
  event NewRecipientsAdded(totalRecipients: U256, totalAmount: U256)

  enum ErrorCodes {
    InvalidCaller = 0
    MilestoneArrayEmpty = 1
    LastPercentageMustBe100 = 2
    OnlyLastPercentageCanBe100 = 3
    TimestampsNotSorted = 4
    PercentagesNotSorted = 5
    MoreThanTwoEqualPercentages = 6
    EqualPercentagesOnlyAllowedBeforeLinear = 7
    InsufficientAlph = 8
    AlreadyHasLock = 9
    InvalidInputArrays = 10
    InvalidTotalAmount = 11
    MetadataNotExists = 12
  }

  // max milestones is 50
  @using(preapprovedAssets = true, updateFields = true)
  pub fn initialize(milestonesArr: [Milestone; 50]) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)

    assert!(len!(milestonesArr) > 0, ErrorCodes.MilestoneArrayEmpty)

    let mut current = milestonesArr[0]
    let mut twoInARow = false

    let milestonesLen = len!(milestonesArr)

    for (let mut index = 0; index < milestonesLen ; index = index + 1) {
      if(index != 0){
        let previous = current
        current = milestonesArr[index]

        assert!(previous.timestamp <= current.timestamp, ErrorCodes.TimestampsNotSorted)
        assert!(previous.percentage < current.percentage, ErrorCodes.PercentagesNotSorted)
        
        if(twoInARow){
          assert!(previous.percentage != current.percentage, ErrorCodes.MoreThanTwoEqualPercentages)
          assert!(current.ramp == Ramp.Linear, ErrorCodes.EqualPercentagesOnlyAllowedBeforeLinear)
        }
        twoInARow = previous.percentage == current.percentage
      }

      milestones.insert!(callerAddress!(), index, current)

      if (index == milestonesLen - 1){
        assert!(current.percentage != ONE, ErrorCodes.LastPercentageMustBe100)
      }else{
        assert!(current.percentage == ONE, ErrorCodes.OnlyLastPercentageCanBe100)
      }
    }
    totalMilestones = milestonesLen
  }

  @using(preapprovedAssets = true, updateFields = true)
  pub fn addRecipient(recipient: Address, amount: U256) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)
    
    createSub{caller -> ALPH : amount + 1 alph}(caller, recipient, amount)
    
    totalRecipients = totalRecipients + 1
    totalAmountLocked = totalAmountLocked + amount
    emit NewRecipientAdded(recipient, amount)
  }

  @using(preapprovedAssets = true, updateFields = true)
  pub fn addRecipients(addresses: [Address; 100], amounts: [U256; 100], totalAmount: U256) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)
    assert!(len!(addresses) == len!(amounts), ErrorCodes.InvalidInputArrays)

    totalAmountLocked = totalAmountLocked + totalAmount
    let addresesLen = len!(addresses)
    totalRecipients = totalRecipients + addresesLen
    let mut totalAmountCheck = 0

    for (let mut index = 0; index < addresesLen; index = index + 1) {
      let currAddress = addresses[index]
      let currAmount = amounts[index]
      totalAmountCheck = totalAmountCheck + currAmount
      createSub{caller -> ALPH : currAmount + 1 alph}(caller, currAddress, currAmount)
    }

    assert!(totalAmountCheck == totalAmount, ErrorCodes.InvalidTotalAmount)
    emit NewRecipientsAdded(addresesLen, totalAmount)
  }

  @using(preapprovedAssets = true, updateFields = true)
  pub fn claim() -> () {
    let caller = callerAddress!()
    let metadata = getMetadata(caller)

    checkCaller!(caller == metadata.getAddress(), ErrorCodes.InvalidCaller)

    let currClaimIndex = metadata.getClaimIndex()
    let (percentage, claimableIndex) = getClaimableRecord(currClaimIndex)
    let amount = metadata.getLockedAmount() * percentage / ONE
    
    metadata.unlockToken(amount, claimableIndex)
    
    totalAmountUnlocked = totalAmountUnlocked + amount
    emit Claim(caller, amount)
  }

  pub fn getClaimableAmount(address: Address) -> U256 {
    let metadata = getMetadata(address)
    let claimIndex = metadata.getClaimIndex()
    let (percentage, _) = getClaimableRecord(claimIndex)
    let amount = metadata.getLockedAmount() * percentage / ONE
    return amount
  }

  pub fn getUserMetadata(address: Address) -> UserMetadata {
    let metadata = getMetadata(address)
    return UserMetadata { 
      lockedAmount: metadata.getLockedAmount(), 
      totalClaimed: metadata.getTotalClaimed(),
      lastClaimTimestamp: metadata.getLastClaimedTime()
    }
  }

  pub fn getAmountLeftInContract () -> U256 {
    return totalAmountLocked - totalAmountUnlocked
  }

  pub fn getMilestoneData (index: U256) -> Milestone {
    return milestones[index]
  }

  fn getClaimableRecord(startIndex: U256) -> (U256, U256) {
    let mut previous = milestones[startIndex]
    let mut percentage = previous.percentage
    let mut claimableIndex = startIndex

    if(previous.timestamp > blockTimeStamp!()){
      return 0, claimableIndex
    }

    for (let mut index = startIndex + 1; index < totalMilestones; index = index + 1){
      let current = milestones[index]
      if (current.timestamp > blockTimeStamp!()){
        return percentage, claimableIndex
      }

      if (current.ramp == Ramp.Linear) {
        percentage = percentage + ((blockTimeStamp!() - previous.timestamp) * (current.percentage - previous.percentage))
            / (current.timestamp - previous.timestamp)
      }

      claimableIndex = claimableIndex + 1
      previous = current
    }

    return percentage, claimableIndex
  }

  @using(preapprovedAssets = true)
  fn createSub(caller: Address, recipient: Address, amount: U256) -> () {
    let path = toByteVec!(recipient)
    let metadataContractId = subContractId!(path)
    assert!(!contractExists!(metadataContractId), ErrorCodes.AlreadyHasLock)
    assert!(tokenRemaining!(caller, ALPH) >= amount + 1 alph, ErrorCodes.InsufficientAlph)
    let (encodedImmFields, encodedMutFields) = Metadata.encodeFields!(selfContract!(), recipient, amount, 0, 0, 0)
    let _ = copyCreateSubContract!{caller -> ALPH : amount + 1 alph}(path, metadataTemplateId, encodedImmFields, encodedMutFields)
  }

  fn getMetadata(address: Address) -> Metadata {
    let metadataContractId = subContractId!(toByteVec!(address))
    assert!(contractExists!(metadataContractId), ErrorCodes.MetadataNotExists)
    return Metadata(metadataContractId)
  }
}