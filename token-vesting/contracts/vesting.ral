struct UserVestingSchedule {
  startTime: U256,
  cliffTime: U256,
  endTime: U256,
  lockedAmount: U256,
  totalClaimed: U256
}

Contract Vesting(
  metadataTemplateId: ByteVec,
  manager: Address,
  mut totalSchedules: U256
){
  event Claim(recipient: Address, amount: U256)

  event NewScheduleAdded(recipient: Address, startTime: U256, cliffTime:U256, endTime: U256, totalAmount: U256)
  
  event VestingEndedByOwner(addressToEnd: Address, amountWithdrawable: U256, amountRefundable: U256)

  enum ErrorCodes {
    InvalidCaller = 0
    InvalidCliffTime = 1
    InvalidEndTime = 2
    InvalidPercentage = 3
    InsufficientAlph = 4
    AlreadyHasLock = 5
    MetadataNotExists = 6
  }

  @using(preapprovedAssets = true, updateFields = true)
  pub fn addVestingScheduleWithPercentage(recipient: Address, startTime: U256, cliffTime: U256, endTime: U256, totalAmount: U256, percentage: U256) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)
    assert!(percentage <= 100, ErrorCodes.InvalidPercentage)

    assert!(cliffTime >= startTime,ErrorCodes.InvalidCliffTime)
    assert!(endTime >= cliffTime, ErrorCodes.InvalidEndTime)

    let vestAmount = (totalAmount * percentage) / 100

    createSub{caller -> ALPH : vestAmount + 1 alph}(caller, recipient, startTime, cliffTime, endTime, vestAmount)
    
    totalSchedules = totalSchedules + 1

    emit NewScheduleAdded(recipient, startTime, cliffTime, endTime, totalAmount)
  }

  @using(preapprovedAssets = true, updateFields = true)
  pub fn addVestingSchedule(recipient: Address, startTime: U256, cliffTime: U256, endTime: U256, totalAmount: U256) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)

    assert!(cliffTime >= startTime,ErrorCodes.InvalidCliffTime)
    assert!(endTime >= cliffTime, ErrorCodes.InvalidEndTime)

    createSub{caller -> ALPH : totalAmount + 1 alph}(caller, recipient, startTime, cliffTime, endTime, totalAmount)
    
    totalSchedules = totalSchedules + 1

    emit NewScheduleAdded(recipient, startTime, cliffTime, endTime, totalAmount)
  }

  pub fn endVesting(addressToEnd: Address, refundAddress: Address) -> () {
    let caller = callerAddress!()
    checkCaller!(caller == manager, ErrorCodes.InvalidCaller)

    let metadata = getMetadata(addressToEnd)

    let mut amountRefundable = 0
    let mut amountWithdrawable = 0

    if(blockTimeStamp!() < metadata.getCliffTime()){
      amountRefundable = metadata.getTotalAmountLocked()
    }else{
      let totalAmountVested = metadata.getTotalAmountVested()
      amountWithdrawable = totalAmountVested - metadata.getTotalAmountClaimed()
      amountRefundable = metadata.getTotalAmountLocked() - totalAmountVested
    }

    if(amountWithdrawable > 0){
      metadata.makeTransfer(addressToEnd, amountWithdrawable)
    }

    if(amountRefundable > 0){
      metadata.makeTransfer(refundAddress, amountRefundable)
    }

    metadata.removeVestingSchedule()

    emit VestingEndedByOwner(addressToEnd, amountWithdrawable, amountRefundable)
  }
 
  pub fn claim() -> (){
    let caller = callerAddress!()
    let metadata = getMetadata(caller)

    let prevClaimed = metadata.getTotalAmountClaimed()

    checkCaller!(caller == metadata.getAddress(), ErrorCodes.InvalidCaller)

    metadata.unlockToken()

    let currClaimed = metadata.getTotalAmountClaimed()

    emit Claim(caller, currClaimed - prevClaimed)
  }

  pub fn getUserVestingSchedule() -> UserVestingSchedule {
    let caller = callerAddress!()
    let metadata = getMetadata(caller)

    return UserVestingSchedule {
      startTime: metadata.getStartTime(),
      cliffTime: metadata.getCliffTime(),
      endTime: metadata.getEndTime(),
      lockedAmount: metadata.getTotalAmountLocked(),
      totalClaimed: metadata.getTotalAmountClaimed()
    }
  }

  @using(preapprovedAssets = true)
  fn createSub(caller: Address, recipient: Address, startTime: U256, cliffTime: U256, endTime: U256, totalAmount: U256) -> () {
    let path = toByteVec!(recipient)
    let metadataContractId = subContractId!(path)
    assert!(!contractExists!(metadataContractId), ErrorCodes.AlreadyHasLock)
    assert!(tokenRemaining!(caller, ALPH) >= totalAmount + 1 alph, ErrorCodes.InsufficientAlph)
    let (encodedImmFields, encodedMutFields) = Metadata.encodeFields!(selfContract!(), recipient, startTime, cliffTime, endTime, totalAmount, 0)
    let _ = copyCreateSubContract!{caller -> ALPH : totalAmount + 1 alph}(path, metadataTemplateId, encodedImmFields, encodedMutFields)
  }

  fn getMetadata(address: Address) -> Metadata{
    let metadataContractId = subContractId!(toByteVec!(address))
    assert!(contractExists!(metadataContractId), ErrorCodes.MetadataNotExists)
    return Metadata(metadataContractId)
  }
}